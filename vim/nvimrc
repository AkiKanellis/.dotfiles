" Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif

if &compatible
    set nocompatible
endif

"----------------
" install plugin
"-----------------

call plug#begin('~/nvim/plugged')

" display the result when searching
Plug 'henrik/vim-indexed-search'

" syntax highlighting for tmux.conf + other cool options
Plug 'tmux-plugins/vim-tmux' | Plug 'tmux-plugins/vim-tmux-focus-events'
" seemless navigation between vim windows / tmux pane
Plug 'christoomey/vim-tmux-navigator'

" wrapper for git and display git diff in the left gutter
Plug 'tpope/vim-fugitive' | Plug 'airblade/vim-gitgutter'
" surrounding with whatever you want (paranthesis, quotes...)
Plug 'tpope/vim-surround'
" easily search, substitute and abbreviate multiple version of words
Plug 'tpope/vim-abolish'
" the . command can repeat whatever you want!
" http://vimcasts.org/episodes/creating-repeatable-mappings-with-repeat-vim/
Plug 'tpope/vim-repeat'
" comment automatically
Plug 'tpope/vim-commentary'

" camel case motion
Plug 'chaoren/vim-wordmotion'

" See man pages in vim
Plug 'jez/vim-superman'

" Match more stuff with % (html tag, LaTeX...)
Plug 'tmhedberg/matchit'

" General autocomplete system
Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }

" vim project for one specific vimrc / project + startify for startup cow
Plug 'amiorin/vim-project'
Plug 'mhinz/vim-startify'

" general quality tools 
Plug 'neomake/neomake'
Plug 'phpstan/vim-phpstan'

" snippets
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'

" markdown 
Plug 'godlygeek/tabular'
Plug 'plasticboy/vim-markdown'

" php autocompletion engine and tools
Plug 'mkusher/padawan.vim'
Plug 'padawan-php/deoplete-padawan'

Plug 'StanAngeloff/php.vim'
Plug 'stephpy/vim-php-cs-fixer'
Plug 'arnaud-lb/vim-php-namespace'
Plug 'nishigori/vim-php-dictionary'

" refactoring options
Plug 'adoy/vim-php-refactoring-toolbox', {'for': 'php'}

" twig
Plug 'lumiliet/vim-twig'

" php doc autocompletion
Plug 'tobyS/vmustache' | Plug 'tobyS/pdv'

" javascript plugins
Plug 'pangloss/vim-javascript'
" need to run npm install in the folder ~/nvim/plugged/tern_for_vim
Plug 'ternjs/tern_for_vim', { 'for': ['javascript', 'javascript.jsx'] }
Plug 'carlitux/deoplete-ternjs', { 'for': ['javascript', 'javascript.jsx'] }
Plug 'othree/jspc.vim', { 'for': ['javascript', 'javascript.jsx'] }

Plug 'beyondwords/vim-twig'
" Syntax highlighting for vue js framework
Plug 'posva/vim-vue'

" autoclose bracket and parenthesis when open
Plug 'Townk/vim-autoclose'

" debugger
Plug 'joonty/vdebug'

" outliner
Plug 'majutsushi/tagbar'

" Nerdtree + modifications: git icons plugin, color filetype plugin
Plug 'scrooloose/nerdtree', { 'on': ['NERDTreeToggle', 'NERDTreeFind']}
" Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
" Plug 'ryanoasis/vim-devicons'

" status bar
Plug 'itchyny/lightline.vim'

" undo tree
Plug 'sjl/gundo.vim'

" registers
Plug 'vim-scripts/YankRing.vim'

" close the current buffer
Plug 'moll/vim-bbye'

" fzf - poweful search
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'

" allow multisearch in current directory / multi replace as well
Plug 'wincent/ferret'

" display the hexadecimal colors - useful for css and color config
Plug 'ap/vim-css-color'

" easy way to rezise and exchange windows
Plug 'simeji/winresizer'

call plug#end()


"----------------
" plugin config
"----------------

" Add composer to the general path
let $PATH=$PATH . ':' . expand('~/composer/vendor/bin')

source ~/nvim/pluggedconf/deoplete.nvimrc
source ~/nvim/pluggedconf/nerdtree.nvimrc
source ~/nvim/pluggedconf/lightline.nvimrc
source ~/nvim/pluggedconf/fzf.nvimrc
source ~/nvim/pluggedconf/vdebug.nvimrc
source ~/nvim/pluggedconf/neomake.nvimrc
source ~/nvim/pluggedconf/project-vim.nvimrc
source ~/nvim/pluggedconf/phpnamespace.nvimrc
source ~/nvim/pluggedconf/php-refactoring-toolbox.nvimrc
source ~/nvim/pluggedconf/phpactor.nvimrc
source ~/nvim/pluggedconf/php-cs-fixer.nvimrc
source ~/nvim/pluggedconf/ferret.nvimrc
source ~/nvim/pluggedconf/phpstan.nvimrc

" project config - is not on my git repository (but on my personal nextcloud)
source ~/nvim/projects.nvimrc

" vim-wordmotion
let g:wordmotion_prefix = 'c'

" markdown
let g:vim_markdown_folding_disabled = 1

" vim comment
autocmd FileType php setlocal commentstring=\/\/\ %s

" ultisnips
let g:UltiSnipsExpandTrigger="<C-s>"

" close the buffer
nmap <leader>db :Bdelete!<cr>

" go to definition of a method / class / whatever via Ctags
map <leader>] :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" YankRing
nnoremap <leader>r :YRShow<cr> 

" Startify config
let g:startify_list_order = ['bookmarks']

" php docs
let g:pdv_template_dir = $HOME ."/nvim/plugged/pdv/templates_snip"
autocmd FileType php noremap <leader>d :call pdv#DocumentWithSnip()<CR>

" Using a snippet for documentation?
" let g:pdv_template_dir = $HOME."/.vim/pdv_templates_snip"

" write ctags each time we change a php file
au BufWritePost *.php silent! !eval '[ -f ".git/hooks/ctags" ] && .git/hooks/ctags'
au BufWritePost *.js silent! !eval '[ -f ".git/hooks/ctags" ] && .git/hooks/ctags'

" Twig
autocmd BufNewFile,BufRead *.twig set filetype=html.twig

"------------------
" general binding
"------------------

" Weird hack for NERDTree to work
let mapleader = "\\"
map <SPACE> <leader>

" Go to next line and quit insert mode
nmap <leader>o o<esc>

" paste mode in order to paste correctly the formating from the clipboard
nnoremap <leader>p :set paste!<CR>

" un-highlight when esc is pressed (after search for example)
map <esc> :noh<cr>

" Enables you to save files with :w!! by using sudo if you forgot to open it as root
cmap w!! %!sudo tee > /dev/null %" display tabs, trailing spaces

" indent without kill the selection in vmode
vmap < <gv
vmap > >gv

" remap the annoying u in visual mode
vmap u y

" shortcut to substitute current word under cursor
nnoremap <leader>[ :%s/<c-r><c-w>/<c-r><c-w>/g<left><left>

" reformat with external tools
autocmd FileType xml nnoremap <leader>c :%!xmllint --format - <cr>
autocmd FileType json nnoremap <leader>c :%!python -m json.tool<cr>

" html
nmap <leader><F3> :%s/<[^>]*>/\r&\r/g<cr>gg=G:g/^$/d<cr><leader>/

" tabs - I never use them but well
nnoremap th :tabfirst<CR>
nnoremap tj :tabnext<CR>
nnoremap tk :tabprev<CR>
nnoremap tl :tablast<CR>
nnoremap tn :tabnew<CR>

" windows management

" windows navigation
nnoremap <leader>ww <c-w>w
nnoremap <leader>wh <c-w>h
nnoremap <leader>wj <c-w>j
nnoremap <leader>wk <c-w>k
nnoremap <leader>wl <c-w>l

" close all windows except the current one
nnoremap <leader>wco :only<cr>
nnoremap <leader>wcc :cclose<cr>

" windows creation

" create window on the bottom
nnoremap <leader>wb <c-w>s
" create vertival window
nnoremap <leader>wv <c-w>v

" resize the windows
nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR>
nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>

" delete character after cursor in insert mode
inoremap <C-d> <Del>

" highlight the line which is longer than the defined margin (120 character)
highlight ColorColumn ctermbg=red
call matchadd('ColorColumn', '\%120v', 100)

" select last paste in visual mode
nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'

" open devdocs.io with firefox and search the word under the cursor
command! -nargs=? DevDocs :call system('type -p open >/dev/null 2>&1 && open http://devdocs.io/#q=<args> || firefox -url http://devdocs.io/#q=<args>')
au FileType python,ruby,rspec,javascript,html,php,eruby,coffee,haml nmap <buffer> <leader>D :exec "DevDocs " . fnameescape(expand('<cword>'))<CR>

" disable arrow keys - don't use arrow keys in Vim!
map <up> <nop>
map <down> <nop>
map <left> <nop>
map <right> <nop>
imap <up> <nop>
imap <down> <nop>
imap <left> <nop>
imap <right> <nop>

" buffer cleanup - delete every buffer except the one open
function! Buflist()
    redir => bufnames
    silent ls
    redir END
    let list = []
    for i in split(bufnames, "\n")
        let buf = split(i, '"' )
        call add(list, buf[-2])
|   endfor
    return list
endfunction

function! Bdeleteonly()
    let list = filter(Buflist(), 'v:val != bufname("%")')
    for buffer in list
        exec "bdelete ".buffer
    endfor
endfunction

command! Ball :silent call Bdeleteonly()

" restore the position of the last cursor when you open a file
au BufReadPost * call RestorePosition()
func! RestorePosition()
    if exists("g:restore_position_ignore") && match(expand("%"), g:restore_position_ignore) > -1
        return
    endif

    if line("'\"") > 1 && line("'\"") <= line("$")
        exe "normal! g`\""
    endif
endfunc

" edit vimrc with f5 and source it automatically when saved
nmap <silent> <leader><f5> :e $MYVIMRC<CR>
augroup reload_vimrc
    autocmd!
    autocmd BufWritePost $MYVIMRC nested source $MYVIMRC
augroup END

" Create automatically test files / can switch between tests and tested files
" Super powerful for TDD!!

" firstDirBeginning: test path / secondDirBeginning: source path
" a fifth argument can be added if tests is in a subdirectory
" a sixth argument can be added to use a special command to open the file (like vsp)

" example:
" autocmd FileType php nmap <silent> <leader>tu :call SwitchBetweenFiles('php', 'src/Tests/', 'src/', 'Test', 'src', ':sp'  )<cr>
" src/Tests/Model/ModelTest.php - src/Model/Model.php
function! SwitchBetweenFiles(fileExtension, firstDirBeginning, secondDirBeginning, filenameAddition, ...)
    let f = bufname("%")
    if exists("a:2")
        let openFileCommand = a:2
    else
        let openFileCommand = ":e"
    endif

    if f =~ '.'.a:fileExtension
        if f =~ '\<'.a:firstDirBeginning && f =~ a:filenameAddition.'\.'.a:fileExtension
            let filename = substitute(substitute(f, a:firstDirBeginning, '', ''), a:filenameAddition, '', '')

            if exists("a:1") && !empty(a:1)
                let filename = a:1.'/'.filename
            endif

            if !filereadable(filename)
                let new_dir = substitute(filename, '/\w\+\.'.a:fileExtension, '', '')
                exe ":!mkdir -p ".new_dir
            endif

            exe openFileCommand." ".filename

        elseif f =~ '\<'.a:secondDirBeginning && f !~ a:filenameAddition.'\.'.a:fileExtension
            let filename = substitute(substitute(f, a:secondDirBeginning, a:firstDirBeginning.a:secondDirBeginning, ''), '.'.a:fileExtension, a:filenameAddition.'.'.a:fileExtension, '')

            if exists("a:1") && !empty(a:1)
                let filename = substitute(filename, '/'.a:1, '', '')
            endif

            if !filereadable(filename)
                let new_dir = substitute(filename, '/\w\+'.a:filenameAddition.'\.'.a:fileExtension, '', '')
                exe ":!mkdir -p ".new_dir
            endif
            exe openFileCommand." ".filename
        else
            echom "Could not switch because needed patterns not matched."
        endif
    endif
endfunction

" FormatPHPLineLength - can split array or list of arguments on multiple lines. Very Handy!
" Make it available for all languages?
function! FormatPHPLineLength()
    let l:currentLine = getline('.')
    normal! ma

    let l:isConditional = l:currentLine =~ '\s*&&' || l:currentLine =~ ' and ' || l:currentLine =~ '\s*||' || l:currentLine =~ ' or ' || l:currentLine =~ '\s*?.*:'
    if l:isConditional
        :s/\(\s*&&\| and \|\s*||\| or \| ?\| :\)/\r\1/g
        if getline('.') =~ ') {'
            exe "normal! $hhi\n"
        endif
        normal! =ip
    endif

    " split params
    let l:isFunctionCall = len(split(l:currentLine, '(.\+)', 1)) - 1
    if l:isFunctionCall > 0
        try
            s#\((\)\([^)]\+\)\().*\)#\1\r\2\r\3#
            normal! k
            if getline('.') =~ ',\s'
                s/,\s/,\r/g
            endif
            normal! j
            if getline('.') =~ '))'
                exe "normal! kJa\n"
            endif
            normal! =a(
        catch
        endtry
    endif

    " format array
    let l:isArray = len(split(l:currentLine, '.\+\zs\[.\+\]', 1)) - 1
    if l:isArray > 0
        try
            s/\(\[\)\(.\+\)\(]\)/\1\r\2\r\3

            normal! k

            if l:currentLine =~ ',\s'
                s/,\s/,\r/g
            endif

            if getline('.') !~ ',$'
                normal! A,
            endif

            normal! =a[
        catch
        endtry
    endif

    " " multiple object operator split - repeatable
    let l:numOfObjectOperators = len(split(l:currentLine, '->', 1)) - 1
    if l:numOfObjectOperators > 1
        try
            s/.*->.*\zs->/\r->/g
            normal! ='a
        catch
        endtry
    endif
endfunction
nnoremap <leader>G :call FormatPHPLineLength()<cr>

" delete trailing space when saving files
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc

autocmd BufWrite *.php :call DeleteTrailingWS()
autocmd BufWrite *.js :call DeleteTrailingWS()
autocmd BufWrite *.vue :call DeleteTrailingWS()
autocmd BufWrite *.twig :call DeleteTrailingWS()
autocmd BufWrite *.html :call DeleteTrailingWS()

" Simple Zoom / Restore window (a bit like Tmux)
function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        execute t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vertical resize
        let t:zoomed = 1
    endif
endfunction
command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <Leader>z :ZoomToggle<CR>

"-----------------
" general config 
"-----------------

" change cursor in nvim
let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

" colorscheme
colo hypnos

" set the directory where the swap file will be saved
set backupdir=~/nvim/backup//
set directory=~/nvim/swap//

" save undo trees in files
set undofile
set undodir=~/nvim/undo//

" set line number
set number

" the copy goes to the clipboard
set clipboard+=unnamedplus

" use 4 spaces instead of tab (to replace existing tab use :retab)
" copy indent from current line when starting a new line
set autoindent
set expandtab
set tabstop=4
set softtabstop=4
set shiftwidth=4
" when at 3 spaces, and I hit > ... go to 4, not 7
set shiftround

" Use case insensitive search, except when using capital letters
set ignorecase
set smartcase

set list
let &listchars="tab:▸,trail:,extends:❯,precedes:❮,nbsp:±"
" let &listchars = 'tab:▸,extends:❯,precedes:❮,nbsp:±,trail:'

" doesn't prompt a warning when opening a file and the current file was written but not saved 
set hidden

" doesn't display the mode status
set noshowmode

" Keep cursor more in middle when scrolling down / up
set scrolloff=15

" no swap file! This is just annoying
set noswapfile

" write automatically when quitting buffer
set autowrite
